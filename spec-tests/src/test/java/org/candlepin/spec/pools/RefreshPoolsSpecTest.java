/**
 * Copyright (c) 2009 - 2022 Red Hat, Inc.
 *
 * This software is licensed to you under the GNU General Public License,
 * version 2 (GPLv2). There is NO WARRANTY for this software, express or
 * implied, including the implied warranties of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2
 * along with this software; if not, see
 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
 *
 * Red Hat trademarks are not licensed under GPLv2. No permission is
 * granted to use or replicate Red Hat trademarks that are incorporated
 * in this software or its documentation.
 */
package org.candlepin.spec.pools;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.entry;
import static org.assertj.core.api.Assertions.from;
import static org.candlepin.spec.bootstrap.assertions.StatusCodeAssertions.assertNotFound;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;

import org.candlepin.dto.api.client.v1.AsyncJobStatusDTO;
import org.candlepin.dto.api.client.v1.BrandingDTO;
import org.candlepin.dto.api.client.v1.CertificateDTO;
import org.candlepin.dto.api.client.v1.CertificateSerialDTO;
import org.candlepin.dto.api.client.v1.ConsumerDTO;
import org.candlepin.dto.api.client.v1.ContentDTO;
import org.candlepin.dto.api.client.v1.EntitlementDTO;
import org.candlepin.dto.api.client.v1.OwnerDTO;
import org.candlepin.dto.api.client.v1.PoolDTO;
import org.candlepin.dto.api.client.v1.ProductDTO;
import org.candlepin.dto.api.client.v1.ProvidedProductDTO;
import org.candlepin.dto.api.client.v1.SubscriptionDTO;
import org.candlepin.spec.bootstrap.assertions.CandlepinMode;
import org.candlepin.spec.bootstrap.assertions.OnlyInHosted;
import org.candlepin.spec.bootstrap.client.ApiClient;
import org.candlepin.spec.bootstrap.client.ApiClients;
import org.candlepin.spec.bootstrap.client.SpecTest;
import org.candlepin.spec.bootstrap.data.builder.Branding;
import org.candlepin.spec.bootstrap.data.builder.ConsumerTypes;
import org.candlepin.spec.bootstrap.data.builder.Consumers;
import org.candlepin.spec.bootstrap.data.builder.Content;
import org.candlepin.spec.bootstrap.data.builder.Owners;
import org.candlepin.spec.bootstrap.data.builder.ProductAttributes;
import org.candlepin.spec.bootstrap.data.builder.Products;
import org.candlepin.spec.bootstrap.data.builder.Subscriptions;
import org.candlepin.spec.bootstrap.data.util.CertificateUtil;
import org.candlepin.spec.bootstrap.data.util.StringUtil;

import com.fasterxml.jackson.databind.JsonNode;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

@SpecTest
public class RefreshPoolsSpecTest {
    private static final String POOL_REFRESH_RESULT_PREFIX = "Pools refreshed for owner: ";

    private ApiClient adminClient;
    private OwnerDTO owner;
    private String ownerKey;

    @BeforeEach
    public void setup() {
        adminClient = ApiClients.admin();
        owner = adminClient.owners().createOwner(Owners.random());
        ownerKey = owner.getKey();
    }

    @Test
    @OnlyInHosted
    public void shouldCreateValidJob() {
        AsyncJobStatusDTO status = refreshPools(adminClient, ownerKey);
        assertEquals(POOL_REFRESH_RESULT_PREFIX + owner.getDisplayName(), status.getResultData());
    }

    @Test
    public void shouldContainTheProperValueWhenOwnerIsAutoGenerated() {
        String expectedKey = StringUtil.random("autoKey-");
        AsyncJobStatusDTO status = refreshPools(adminClient, expectedKey);

        if (CandlepinMode.isHosted()) {
            assertEquals(POOL_REFRESH_RESULT_PREFIX + expectedKey, status.getResultData());
        }
        else {
            assertNull(status);
        }

        OwnerDTO owner = adminClient.owners().getOwner(expectedKey);
        assertNotNull(owner);
        assertEquals(expectedKey, owner.getDisplayName());
        assertEquals(Owners.SCA_ACCESS_MODE, owner.getContentAccessMode());
    }

    @Test
    @OnlyInHosted
    public void shouldCreateTheCorrectNumberOfPools() {
        int expectedSubscriptionCount = 6;
        Set<String> expectedSubIds = new HashSet<>();
        for (int i = 0; i < expectedSubscriptionCount; i++) {
            ProductDTO prod = adminClient.hosted().createProduct(Products.random());
            SubscriptionDTO sub = adminClient.hosted().createSubscription(Subscriptions.random(owner, prod));
            expectedSubIds.add(sub.getId());
        }

        refreshPools(adminClient, ownerKey);

        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools)
            .hasSize(expectedSubscriptionCount)
            .map(PoolDTO::getSubscriptionId)
            .isNotNull()
            .containsExactlyInAnyOrderElementsOf(expectedSubIds);
    }

    @Test
    @OnlyInHosted
    public void shouldDetectChangesInProviderProducts() {
        ProductDTO prod1 = adminClient.hosted().createProduct(Products.random());
        ProductDTO prod2 = adminClient.hosted().createProduct(Products.random());
        ProductDTO providerProduct = Products.random();
        providerProduct.setProvidedProducts(Set.of(prod1, prod2));
        providerProduct = adminClient.hosted().createProduct(providerProduct);
        adminClient.hosted().createSubscription(Subscriptions.random(owner, providerProduct));

        refreshPools(adminClient, ownerKey);
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());

        PoolDTO actualPool = pools.get(0);
        Set<String> expectedProvProdIds = Set.of(prod1.getId(), prod2.getId());
        assertThat(actualPool.getProvidedProducts())
            .isNotNull()
            .map(ProvidedProductDTO::getProductId)
            .hasSameSizeAs(expectedProvProdIds)
            .hasSameElementsAs(expectedProvProdIds);

        // Remove the old provided products and add a new one...
        ProductDTO prod3 = adminClient.hosted().createProduct(Products.random());
        providerProduct.setProvidedProducts(Set.of(prod3));
        providerProduct = adminClient.hosted().updateProduct(providerProduct.getId(), providerProduct);

        refreshPools(adminClient, ownerKey);
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools)
            .isNotNull()
            .hasSize(1);

        assertThat(pools.get(0).getProvidedProducts())
            .isNotNull()
            .singleElement()
            .returns(prod3.getId(), from(ProvidedProductDTO::getProductId));
    }

    @Test
    @OnlyInHosted
    public void shouldDetectChangesInBranding() {
        BrandingDTO brand1 = Branding.random();
        brand1.setProductId(StringUtil.random("prod-"));
        ProductDTO product = adminClient.hosted()
            .createProduct(Products.random().branding(Set.of(brand1)));
        adminClient.hosted().createSubscription(Subscriptions.random(owner, product));

        refreshPools(adminClient, ownerKey);
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());
        assertEquals(1, pools.get(0).getBranding().size());
        compareBrandings(brand1, pools.get(0).getBranding().stream().iterator().next());

        // Check the branding set is visible on the product.
        List<ProductDTO> products = adminClient.ownerProducts().getProductsByOwner(ownerKey, List.of());
        assertEquals(1, products.size());
        assertEquals(1, products.get(0).getBranding().size());
        compareBrandings(brand1, products.get(0).getBranding().stream().iterator().next());

        // Add an additional branding to the upstream product than the one we had initially...
        BrandingDTO brand2 = Branding.random();
        brand2.setProductId(StringUtil.random("prod-"));
        Set<BrandingDTO> expectedBranding = Set.of(brand1, brand2);
        product.setBranding(expectedBranding);
        adminClient.hosted().updateProduct(product.getId(), product);

        refreshPools(adminClient, ownerKey);
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());
        compareBrandings(expectedBranding, pools.get(0).getBranding());

        // Check the updated branding set is visible on the product.
        products = adminClient.ownerProducts().getProductsByOwner(ownerKey, List.of());
        assertEquals(1, products.size());
        Set<BrandingDTO> actualBranding = products.get(0).getBranding();
        compareBrandings(expectedBranding, actualBranding);
    }

    @Test
    @OnlyInHosted
    public void shouldDeleteExpiredSubscriptionPoolsAndEntitlements() {
        ProductDTO product = adminClient.hosted().createProduct(Products.random());
        SubscriptionDTO sub = adminClient.hosted().createSubscription(Subscriptions.random(owner, product));

        refreshPools(adminClient, ownerKey);
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());
        PoolDTO pool = pools.get(0);

        ConsumerDTO user = Consumers.random(owner, ConsumerTypes.System);
        user.setUsername("admin");
        user = adminClient.consumers().createConsumer(user, "admin",
        owner.getKey(), null, true);
        ApiClient consumerClient = ApiClients.trustedConsumer(user.getUuid());

        JsonNode ents = consumerClient.consumers().bindPool(user.getUuid(), pool.getId(), 1);
        assertEquals(1, ents.size());

        user = adminClient.consumers().getConsumer(user.getUuid());
        assertEquals(1, user.getEntitlementCount());

        // Update subscription such that it's expired, then refresh. The entitlements should be removed.
        sub.setStartDate(OffsetDateTime.now().minusDays(20L));
        sub.setEndDate(OffsetDateTime.now().minusDays(10L));
        sub = adminClient.hosted().updateSubscription(sub.getId(), sub);

        refreshPools(adminClient, ownerKey);
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(0, pools.size());

        user = adminClient.consumers().getConsumer(user.getUuid());
        assertEquals(0, user.getEntitlementCount());
    }

    @Test
    @OnlyInHosted
    public void shouldRegenerateEntitlements() {
        ProductDTO prod1 = adminClient.hosted().createProduct(Products.random());
        ProductDTO prod2 = adminClient.hosted().createProduct(Products.random());
        SubscriptionDTO sub = adminClient.hosted().createSubscription(Subscriptions.random(owner, prod1));

        refreshPools(adminClient, ownerKey);
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());
        PoolDTO pool = pools.get(0);

        ConsumerDTO user = Consumers.random(owner, ConsumerTypes.System);
        user.setUsername("admin");
        user = adminClient.consumers()
            .createConsumer(user, "admin", owner.getKey(), null, true);
        ApiClient consumerClient = ApiClients.trustedConsumer(user.getUuid());

        JsonNode root = consumerClient.consumers().bindPool(user.getUuid(), pool.getId(), 1);
        assertEquals(1, root.size());
        EntitlementDTO createdEnt = ApiClient.MAPPER.convertValue(root.get(0), EntitlementDTO.class);

        ConsumerDTO consumer = adminClient.consumers().getConsumer(user.getUuid());
        assertEquals(1, consumer.getEntitlementCount());

        CertificateDTO initialCert = createdEnt.getCertificates().stream().iterator().next();
        CertificateSerialDTO initialSerial = initialCert.getSerial();

        // Update the subscription's product to trigger an entitlement regeneration
        sub.setProduct(prod2);
        adminClient.hosted().updateSubscription(sub.getId(), sub);

        refreshPools(adminClient, ownerKey);

        consumer = adminClient.consumers().getConsumer(user.getUuid());
        assertEquals(1, consumer.getEntitlementCount());

        EntitlementDTO updatedEnt = adminClient.entitlements().getEntitlement(createdEnt.getId());
        assertNotNull(updatedEnt);
        CertificateDTO updatedCert = updatedEnt.getCertificates().stream().iterator().next();
        CertificateSerialDTO updatedSerial = updatedCert.getSerial();

        assertNotEquals(initialCert, updatedCert);
        assertNotEquals(initialSerial, updatedSerial);
    }

    @Test
    @OnlyInHosted
    public void shouldHandleDerivedProductsBeingRemoved() {
        ProductDTO derivedEngProduct = adminClient.hosted().createProduct(Products.randomEng());
        ProductDTO derivedProduct = Products.random();
        derivedProduct.providedProducts(Set.of(derivedEngProduct));
        derivedProduct.setAttributes(List.of(ProductAttributes.Cores.withValue("2"),
            ProductAttributes.Sockets.withValue("4")));
        derivedProduct = adminClient.hosted().createProduct(derivedProduct);

        ProductDTO dataCenterProduct = Products.random();
        dataCenterProduct.setAttributes(List.of(ProductAttributes.VirtLimit.withValue("unlimited"),
            ProductAttributes.StackingId.withValue("stackme"),
            ProductAttributes.Sockets.withValue("2"),
            ProductAttributes.MultiEntitlement.withValue("yes")));
        dataCenterProduct.setDerivedProduct(derivedProduct);
        dataCenterProduct = adminClient.hosted().createProduct(dataCenterProduct);
        adminClient.hosted().createSubscription(Subscriptions.random(owner, dataCenterProduct));

        refreshPools(adminClient, ownerKey);
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());

        // We're expecting the base pool + a virt-only bonus pool for guests
        assertThat(pools)
            .hasSize(2)
            .map(PoolDTO::getProductId)
            .containsExactlyInAnyOrder(dataCenterProduct.getId(), derivedProduct.getId());

        dataCenterProduct.setDerivedProduct(null);
        adminClient.hosted().updateProduct(dataCenterProduct.getId(), dataCenterProduct, false);

        refreshPools(adminClient, ownerKey);
        pools = adminClient.pools()
            .listPools(owner.getId(), null, dataCenterProduct.getId(), null, null, null, null, null, null);

        assertThat(pools)
            .hasSize(2)
            .map(PoolDTO::getProductId)
            .containsOnly(dataCenterProduct.getId());

        pools.stream()
            .forEach(pool -> assertEquals(0, pool.getDerivedProvidedProducts().size()));
    }

    @Test
    @OnlyInHosted
    public void shouldMigrateSubscriptions() {
        OwnerDTO owner2 = adminClient.owners().createOwner(Owners.random());
        ProductDTO prod = adminClient.hosted().createProduct(Products.random());
        SubscriptionDTO sub = adminClient.hosted().createSubscription(Subscriptions.random(owner, prod));

        refreshPools(adminClient, owner.getKey());
        refreshPools(adminClient, owner2.getKey());

        assertEquals(1, adminClient.pools().listPoolsByOwner(owner.getId()).size());
        assertEquals(0, adminClient.pools().listPoolsByOwner(owner2.getId()).size());

        // Update sub to be owned by the second owner
        sub.setOwner(Owners.toNested(owner2));
        adminClient.hosted().updateSubscription(sub.getId(), sub);

        refreshPools(adminClient, owner.getKey());
        refreshPools(adminClient, owner2.getKey());

        assertEquals(0, adminClient.pools().listPoolsByOwner(owner.getId()).size());
        assertEquals(1, adminClient.pools().listPoolsByOwner(owner2.getId()).size());
    }

    @Test
    @OnlyInHosted
    public void shouldChangeAttributesAndRevokeEntitlementsAtTheSameTime() {
        ProductDTO prod = Products.random()
            .addAttributesItem(ProductAttributes.MultiEntitlement.withValue("yes"));
        prod = adminClient.hosted().createProduct(prod);
        SubscriptionDTO sub = adminClient.hosted().createSubscription(Subscriptions.random(owner, prod));

        ConsumerDTO user = Consumers.random(owner, ConsumerTypes.System);
        user.setUsername("admin");
        user = adminClient.consumers().createConsumer(user, "admin",
        owner.getKey(), null, true);
        ApiClient consumerClient = ApiClients.trustedConsumer(user.getUuid());

        refreshPools(adminClient, ownerKey);
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());

        // We'll consume quantity 2, later we will reduce the pool to 1 forcing revokation of this entitlement
        JsonNode root = consumerClient.consumers().bindPool(user.getUuid(), pools.get(0).getId(), 2);
        assertEquals(1, root.size());

        // Is this correct? Should it be just one?
        user = adminClient.consumers().getConsumer(user.getUuid());
        assertEquals(2, user.getEntitlementCount());

        // Add a new attribute to the product
        String expectedNewAttName = "arch";
        prod.addAttributesItem(ProductAttributes.Arch.withValue(expectedNewAttName));

        prod = adminClient.hosted().updateProduct(prod.getId(), prod);
        // ...and reduce the quantity available on the subscription
        sub.quantity(1L);
        sub.product(prod);
        sub = adminClient.hosted().updateSubscription(sub.getId(), sub);

        refreshPools(adminClient, ownerKey);
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());

        assertThat(pools.get(0).getProductAttributes())
            .hasSize(2)
            .containsExactlyInAnyOrderElementsOf(prod.getAttributes());

        // Verify that the entitlement was revoked
        user = adminClient.consumers().getConsumer(user.getUuid());
        assertEquals(0, user.getEntitlementCount());

        assertNotFound(() -> adminClient.entitlements().getEntitlement(root.get(0).get("id").asText()));
    }

    @Test
    @OnlyInHosted
    public void shouldRegenerateEntitlementsWhenContentForAnEntitledPoolChanges() {
        ContentDTO content = adminClient.hosted().createContent(Content.random());
        ProductDTO prod = adminClient.hosted().createProduct(Products.random());
        prod = adminClient.hosted().addContentToProduct(prod.getId(), content.getId(), true);
        adminClient.hosted().createSubscription(Subscriptions.random(owner, prod));

        refreshPools(adminClient, ownerKey);
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());

        // Verify the content exists in its initial state
        ContentDTO actualContent = adminClient.ownerContent().getOwnerContent(ownerKey, content.getId());
        assertNotNull(actualContent);
        assertEquals(content.getId(), actualContent.getId());
        assertEquals(content.getType(), actualContent.getType());
        assertEquals(content.getName(), actualContent.getName());
        assertEquals(content.getLabel(), actualContent.getLabel());
        assertEquals(content.getVendor(), actualContent.getVendor());

        // Consume the pool so we have an entitlement
        ConsumerDTO user = Consumers.random(owner, ConsumerTypes.System);
        user.setUsername("admin");
        user = adminClient.consumers().createConsumer(user, "admin",
        owner.getKey(), null, true);
        ApiClient consumerClient = ApiClients.trustedConsumer(user.getUuid());

        JsonNode ents = consumerClient.consumers().bindPool(user.getUuid(), pools.get(0).getId(), 1);
        assertEquals(1, ents.size());
        JsonNode ent = ents.get(0);
        user = adminClient.consumers().getConsumer(user.getUuid());
        assertEquals(1, user.getEntitlementCount());
        String entId = ent.get("id").asText();
        JsonNode cert = ent.get("certificates").get(0);
        CertificateDTO originalCert = ApiClient.MAPPER.convertValue(cert, CertificateDTO.class);
        CertificateSerialDTO originalSerial = originalCert.getSerial();

        // Modify the content for this product/sub
        String expectedLabelUpdated = "updated-label";
        content.setLabel(expectedLabelUpdated);
        content = adminClient.hosted().updateContent(content.getId(), content);

        refreshPools(adminClient, ownerKey);
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());

        // Verify the content change has been pulled down
        content = adminClient.ownerContent().getOwnerContent(ownerKey, content.getId());
        assertEquals(expectedLabelUpdated, content.getLabel());

        // Verify the entitlement cert has changed as a result
        EntitlementDTO updatedEnt = adminClient.entitlements().getEntitlement(entId);
        assertEquals(1, updatedEnt.getCertificates().size());
        CertificateDTO updatedCert = updatedEnt.getCertificates().stream().iterator().next();
        CertificateSerialDTO updatedSerial = updatedCert.getSerial();

        assertNotEquals(originalSerial, updatedSerial);
    }

    @Test
    @OnlyInHosted
    public void shouldRegenerateSCACertWhenContentForAnOrgChanges() {
        OwnerDTO scaOwner = adminClient.owners().createOwner(Owners.randomSca());
        String scaOwnerKey = scaOwner.getKey();

        ContentDTO content = Content.random().contentUrl(StringUtil.random("/url-"));
        content = adminClient.hosted().createContent(content);
        ProductDTO prod = adminClient.hosted().createProduct(Products.random());
        prod = adminClient.hosted().addContentToProduct(prod.getId(), content.getId(), true);
        adminClient.hosted().createSubscription(Subscriptions.random(scaOwner, prod));

        refreshPools(adminClient, scaOwnerKey);
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(scaOwner.getId());
        assertEquals(1, pools.size());

        // Verify the content exists in its initial state
        ContentDTO actualContent = adminClient.ownerContent().getOwnerContent(scaOwnerKey, content.getId());
        assertNotNull(actualContent);
        assertEquals(content.getLabel(), actualContent.getLabel());
        assertEquals(content.getContentUrl(), actualContent.getContentUrl());

        // Register a consumer and check the SCA cert contains the correct content data
        ConsumerDTO user = Consumers.random(scaOwner, ConsumerTypes.System);
        user.setUsername("admin");
        user = adminClient.consumers().createConsumer(user, "admin",
        scaOwnerKey, null, true);
        ApiClient consumerClient = ApiClients.trustedConsumer(user.getUuid());

        List<JsonNode> certificates = consumerClient.consumers().exportCertificates(user.getUuid(), null);
        assertEquals(1, certificates.size());
        JsonNode body = certificates.get(0);
        Map<String, List<String>> prodIdToContentIds = toProductContentIdMap(body);
        assertThat(prodIdToContentIds)
            .isNotNull()
            .hasSize(1)
            .containsOnlyKeys("content_access");

        assertThat(prodIdToContentIds.get("content_access"))
            .isNotNull()
            .singleElement()
            .isEqualTo(content.getId());


        // Modify the content for this product/sub
        String updatedUrl = "http://www.updated-url.com";
        content.setContentUrl(updatedUrl);
        ContentDTO updatedContent = adminClient.hosted().updateContent(content.getId(), content);

        refreshPools(adminClient, scaOwner.getKey());
        pools = adminClient.pools().listPoolsByOwner(scaOwner.getId());
        assertEquals(1, pools.size());

        // Verify the content change has been pulled down
        actualContent = adminClient.ownerContent().getOwnerContent(scaOwnerKey, updatedContent.getId());
        assertNotNull(actualContent);
        assertEquals(updatedContent.getLabel(), actualContent.getLabel());
        assertEquals(updatedContent.getContentUrl(), actualContent.getContentUrl());

        // Verify the SCA cert has changed as a result
        certificates = consumerClient.consumers().exportCertificates(user.getUuid(), null);
        assertEquals(1, certificates.size());
        body = certificates.get(0);
        prodIdToContentIds = toProductContentIdMap(body);
        assertThat(prodIdToContentIds)
            .isNotNull()
            .hasSize(1)
            .containsOnlyKeys("content_access");

        assertThat(prodIdToContentIds.get("content_access"))
            .isNotNull()
            .singleElement()
            .isEqualTo(updatedContent.getId());
    }

    @Test
    @OnlyInHosted
    public void shouldRegenerateEntitlementsWhenProductsForAnEntitledPoolChanges() {
        ContentDTO content = adminClient.hosted().createContent(Content.random());
        ProductDTO prod = adminClient.hosted().createProduct(Products.random());
        prod = adminClient.hosted().addContentToProduct(prod.getId(), content.getId(), true);
        adminClient.hosted().createSubscription(Subscriptions.random(owner, prod));

        refreshPools(adminClient, owner.getKey());
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());

        // Verify the product exists in its initial state
        ProductDTO actualProd = adminClient.ownerProducts().getProductByOwner(ownerKey, prod.getId());
        assertEquals(prod.getId(), actualProd.getId());
        assertEquals(prod.getName(), actualProd.getName());

        // Consume the pool so we have an entitlement
        ConsumerDTO user = Consumers.random(owner, ConsumerTypes.System);
        user.setUsername("admin");
        user = adminClient.consumers().createConsumer(user, "admin",
        ownerKey, null, true);
        ApiClient consumerClient = ApiClients.trustedConsumer(user.getUuid());

        JsonNode ents = consumerClient.consumers().bindPool(user.getUuid(), pools.get(0).getId(), 1);
        assertNotNull(ents);
        assertEquals(1, ents.size());
        user = adminClient.consumers().getConsumer(user.getUuid());
        assertEquals(1, user.getEntitlementCount());

        JsonNode entCert = ents.get(0).get("certificates").get(0);
        JsonNode entSerial = entCert.get("serial").get("serial");

        // Modify the product for this sub
        String updatedName = StringUtil.random("update-");
        prod.setName(updatedName);
        adminClient.hosted().updateProduct(prod.getId(), prod);

        refreshPools(adminClient, owner.getKey());
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());

        // Verify the product change has been pulled down
        actualProd = adminClient.ownerProducts().getProductByOwner(ownerKey, prod.getId());
        assertNotNull(actualProd);
        assertEquals(updatedName, actualProd.getName());

        // Verify the entitlement cert has changed as a result
        EntitlementDTO updatedEnt = adminClient.entitlements().getEntitlement(ents.get(0).get("id").asText());
        assertNotNull(updatedEnt);
        assertEquals(1, updatedEnt.getCertificates().size());
        CertificateDTO updatedCert = updatedEnt.getCertificates().stream().iterator().next();
        assertNotEquals(entSerial.asText(), updatedCert.getSerial().getSerial());
    }

    @Test
    @OnlyInHosted
    public void shouldRegenEntitlementsWhenRequiredProductsChanges() throws Exception {
        ProductDTO engProd1 = adminClient.hosted().createProduct(Products.randomEng());
        ProductDTO engProd2 = adminClient.hosted().createProduct(Products.randomEng());
        ContentDTO content1 = adminClient.hosted().createContent(Content.random());
        ContentDTO content2 = adminClient.hosted().createContent(Content.random());
        ContentDTO content3 = adminClient.hosted().createContent(Content.random());

        engProd1 = adminClient.hosted().addContentToProduct(engProd1.getId(), content1.getId(), true);
        engProd2 = adminClient.hosted().addContentToProduct(engProd2.getId(), content2.getId(), true);
        engProd2 = adminClient.hosted().addContentToProduct(engProd2.getId(), content3.getId(), true);

        ProductDTO skuProd1 = Products.random().providedProducts(Set.of(engProd1));
        ProductDTO skuProd2 = Products.random().providedProducts(Set.of(engProd2));
        skuProd1 = adminClient.hosted().createProduct(skuProd1);
        skuProd2 = adminClient.hosted().createProduct(skuProd2);
        SubscriptionDTO sub1 = adminClient.hosted().createSubscription(Subscriptions.random(owner, skuProd1));
        SubscriptionDTO sub2 = adminClient.hosted().createSubscription(Subscriptions.random(owner, skuProd2));

        refreshPools(adminClient, owner.getKey());
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).map(PoolDTO::getSubscriptionId)
            .containsExactlyInAnyOrder(sub1.getId(), sub2.getId());

        PoolDTO pool1 = pools.get(0).getSubscriptionId().equals(sub1.getId()) ? pools.get(0) : pools.get(1);
        PoolDTO pool2 = pools.get(0).getSubscriptionId().equals(sub2.getId()) ? pools.get(0) : pools.get(1);

        List<ProductDTO> actualProducts = adminClient.ownerProducts().getProductsByOwner(ownerKey, List.of());
        assertThat(actualProducts)
            .map(ProductDTO::getId)
            .containsExactlyInAnyOrder(engProd1.getId(), engProd2.getId(), skuProd1.getId(),
            skuProd2.getId());

        List<ContentDTO> actualContent = adminClient.ownerContent().listOwnerContent(ownerKey);
        assertThat(actualContent)
            .map(ContentDTO::getId)
            .containsExactlyInAnyOrder(content1.getId(), content2.getId(), content3.getId());

        // Consume both pools
        ConsumerDTO user = adminClient.consumers().createConsumer(Consumers
            .random(owner, ConsumerTypes.System), "admin", ownerKey, null, true);
        ApiClient consumerClient = ApiClients.trustedConsumer(user.getUuid());

        JsonNode ents = consumerClient.consumers().bindPool(user.getUuid(), pool1.getId(), 1);
        assertEquals(1, ents.size());
        JsonNode bindEnt1 = ents.get(0);
        ents = consumerClient.consumers().bindPool(user.getUuid(), pool2.getId(), 1);
        assertEquals(1, ents.size());
        JsonNode bindEnt2 = ents.get(0);

        assertThat(adminClient.consumers().listEntitlements(user.getUuid()))
            .map(EntitlementDTO::getId)
            .containsExactlyInAnyOrder(bindEnt1.get("id").asText(), bindEnt2.get("id").asText());

        // Verify the entitlements contains the products and content
        List<String> certs = ApiClient.MAPPER.convertValue(bindEnt1.get("certificates"), List.class);
        List<JsonNode> bindEnt1Certs = CertificateUtil
            .extractEntitlementCertificatesFromPayload(certs, ApiClient.MAPPER);
        certs = ApiClient.MAPPER.convertValue(bindEnt2.get("certificates"), List.class);
        List<JsonNode> bindEnt2Certs = CertificateUtil
            .extractEntitlementCertificatesFromPayload(certs, ApiClient.MAPPER);
        assertEquals(1, bindEnt1Certs.size());
        assertEquals(1, bindEnt2Certs.size());

        Map<String, List<String>> prodIdToContentIds = toProductContentIdMap(bindEnt1Certs.get(0));
        assertThat(prodIdToContentIds)
            .isNotNull()
            .containsExactly(entry(engProd1.getId(), List.of(content1.getId())));

        prodIdToContentIds = toProductContentIdMap(bindEnt2Certs.get(0));
        assertThat(prodIdToContentIds)
            .isNotNull()
            .containsOnlyKeys(engProd2.getId());
        assertThat(prodIdToContentIds.get(engProd2.getId()))
            .isNotNull()
            .containsExactlyInAnyOrder(content2.getId(), content3.getId());

        // Add a dependent product to content2 for a product the consumer is entitled to
        content2.setModifiedProductIds(Set.of(engProd1.getId()));
        adminClient.hosted().updateContent(content2.getId(), content2);

        refreshPools(adminClient, owner.getKey());

        // Verify the content change has been pulled down
        assertEquals(Set.of(engProd1.getId()), adminClient.ownerContent()
            .getOwnerContent(ownerKey, content2.getId()).getModifiedProductIds());

        // Verify the entitlement has been regenerated
        EntitlementDTO updatedEnt = adminClient.entitlements().getEntitlement(bindEnt2.get("id").asText());
        assertEquals(1, updatedEnt.getCertificates().size());
        CertificateDTO cert = updatedEnt.getCertificates().stream().iterator().next();
        assertNotEquals(bindEnt2.get("certificates").get(0).path("serial").path("serial").asText(), cert
            .getSerial().getSerial());

        // Verify the content path is still present in the entitlement
        assertEquals(1, updatedEnt.getCertificates().size());
        CertificateDTO updatedEntCert = updatedEnt.getCertificates().stream().iterator().next();
        JsonNode updatedCert = CertificateUtil
            .decodeAndUncompressCertificate(updatedEntCert.getCert(), ApiClient.MAPPER);

        prodIdToContentIds = toProductContentIdMap(updatedCert);
        assertThat(prodIdToContentIds)
            .isNotNull()
            .containsOnlyKeys(engProd2.getId());

        assertThat(prodIdToContentIds.get(engProd2.getId()))
            .isNotNull()
            .hasSize(2)
            .containsExactlyInAnyOrder(content2.getId(), content3.getId());

        // Add a dependent product to content3 for a product the consumer is NOT entitled to
        String unknownProdId = "unknown";
        content3.setModifiedProductIds(Set.of(unknownProdId));
        content3 = adminClient.hosted().updateContent(content3.getId(), content3);
        refreshPools(adminClient, owner.getKey());

        // Verify the content change has been pulled down
        assertEquals(Set.of(unknownProdId), adminClient.ownerContent()
            .getOwnerContent(ownerKey, content3.getId()).getModifiedProductIds());

        // Verify the entitlement has been regenerated
        updatedEnt = adminClient.entitlements().getEntitlement(bindEnt2.get("id").asText());
        assertEquals(1, updatedEnt.getCertificates().size());
        cert = updatedEnt.getCertificates().stream().iterator().next();
        assertNotEquals(bindEnt2.get("certificates").get(0).path("serial").path("serial").asText(), cert
            .getSerial().getSerial());

        // Verify the content path is still present in the entitlement
        updatedCert = CertificateUtil.decodeAndUncompressCertificate(cert.getCert(), ApiClient.MAPPER);

        prodIdToContentIds = toProductContentIdMap(updatedCert);
        assertThat(prodIdToContentIds)
            .isNotNull()
            .containsExactly(entry(engProd2.getId(), List.of(content2.getId())));
    }

    @Test
    @OnlyInHosted
    public void shouldRegenerateEntitlementsWhenBrandingForAProductOfAnEntitledPoolChanges() {
        BrandingDTO brand = Branding.build(StringUtil.random("brand-"), StringUtil.random("name-"))
            .productId(StringUtil.random("prod-"));
        ProductDTO prod = adminClient.hosted().createProduct(Products.random().branding(Set.of(brand)));
        adminClient.hosted().createSubscription(Subscriptions.random(owner, prod));

        refreshPools(adminClient, owner.getKey());
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());
        PoolDTO pool = pools.get(0);

        // Verify the product exists in its initial state
        ProductDTO actualProd = adminClient.ownerProducts().getProductByOwner(ownerKey, prod.getId());
        assertNotNull(actualProd);
        compareProducts(prod, actualProd);
        compareBrandings(prod.getBranding(), actualProd.getBranding());

        // Consume the pool so we have an entitlement
        ConsumerDTO user = Consumers.random(owner, ConsumerTypes.System);
        user.setUsername("admin");
        user = adminClient.consumers().createConsumer(user, "admin",
        ownerKey, null, true);
        ApiClient consumerClient = ApiClients.trustedConsumer(user.getUuid());

        JsonNode ents = consumerClient.consumers().bindPool(user.getUuid(), pool.getId(), 1);
        assertEquals(1, ents.size());
        JsonNode ent = ents.get(0);
        JsonNode cert = ent.get("certificates").get(0);
        JsonNode serial = cert.get("serial").get("serial");

        user = adminClient.consumers().getConsumer(user.getUuid());
        assertEquals(1, user.getEntitlementCount());

        // Update the name of the branding of the upstream product...
        brand.setName(StringUtil.random("brand-"));
        prod.setBranding(Set.of(brand));
        prod = adminClient.hosted().updateProduct(prod.getId(), prod);

        refreshPools(adminClient, owner.getKey());
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());

        // Verify the branding change on the product has been pulled down
        actualProd = adminClient.ownerProducts().getProductByOwner(ownerKey, prod.getId());
        assertNotNull(actualProd);
        compareProducts(prod, actualProd);
        compareBrandings(prod.getBranding(), actualProd.getBranding());

        // Verify the entitlement cert has changed as a result
        EntitlementDTO updatedEnt = adminClient.entitlements().getEntitlement(ent.get("id").asText());
        assertThat(updatedEnt.getCertificates())
            .singleElement()
            .isNotNull()
            .extracting(CertificateDTO::getSerial)
            .isNotNull()
            .extracting(CertificateSerialDTO::getSerial)
            .isNotEqualTo(serial.asLong());
    }

    @Test
    @OnlyInHosted
    public void shouldInvalidateEntitlementsWhenPoolQuantityIsReduced() {
        ContentDTO content = adminClient.hosted().createContent(Content.random());
        ProductDTO prod = adminClient.hosted().createProduct(Products.random());
        prod = adminClient.hosted().addContentToProduct(prod.getId(), content.getId(), true);
        SubscriptionDTO sub = adminClient.hosted().createSubscription(Subscriptions.random(owner, prod));

        refreshPools(adminClient, owner.getKey());
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());
        assertEquals(sub.getQuantity(), pools.get(0).getQuantity());
        PoolDTO pool = pools.get(0);

        // Verify the product exists in its initial state
        ProductDTO fetchedProd = adminClient.ownerProducts().getProductByOwner(ownerKey, prod.getId());
        compareProducts(prod, fetchedProd);

        // Consume the pool multiple times so we have entitlements to revoke
        for (int i = 0; i < sub.getQuantity(); i++) {
            ConsumerDTO user = Consumers.random(owner, ConsumerTypes.System);
            user.setUsername("admin");
            user = adminClient.consumers().createConsumer(user, "admin",
            owner.getKey(), null, true);
            ApiClient consumerClient = ApiClients.trustedConsumer(user.getUuid());

            JsonNode entNode = consumerClient.consumers().bindPool(user.getUuid(), pool.getId(), 1);
            assertEquals(1, entNode.size());

            user = adminClient.consumers().getConsumer(user.getUuid());
            assertEquals(1, user.getEntitlementCount());
        }

        // Verify the entitlement count for this pool
        List<EntitlementDTO> ents = adminClient.pools().getPoolEntitlements(pool.getId());
        assertEquals(sub.getQuantity(), ents.size());

        // Modify the subscription upstream
        sub.setQuantity(1L);
        adminClient.hosted().updateSubscription(sub.getId(), sub);

        refreshPools(adminClient, owner.getKey());
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());
        pool = pools.get(0);
        assertEquals(sub.getQuantity(), pool.getQuantity());

        // Verify the entitlement count has changed
        ents = adminClient.pools().getPoolEntitlements(pool.getId());
        assertEquals(1, ents.size());
    }

    private AsyncJobStatusDTO refreshPools(ApiClient client, String ownerKey) {
        AsyncJobStatusDTO job = adminClient.owners().refreshPools(ownerKey, true);
        if (!CandlepinMode.isHosted()) {
            return null;
        }

        assertNotNull(job);
        job = adminClient.jobs().waitForJob(job);
        assertEquals("FINISHED", job.getState());

        return job;
    }

    private void compareProducts(ProductDTO expected, ProductDTO actual) {
        assertEquals(expected.getId(), actual.getId());
        assertEquals(expected.getName(), actual.getName());
        assertEquals(expected.getMultiplier(), actual.getMultiplier());
        assertEquals(expected.getAttributes(), actual.getAttributes());
    }

    private void compareBrandings(BrandingDTO expected, BrandingDTO actual) {
        assertEquals(expected.getProductId(), actual.getProductId());
        assertEquals(expected.getName(), actual.getName());
        assertEquals(expected.getType(), actual.getType());
    }

    private void compareBrandings(Collection<BrandingDTO> expected, Collection<BrandingDTO> actual) {
        expected.forEach(brand -> brand.created(null).updated(null));
        actual.forEach(brand -> brand.created(null).updated(null));

        assertThat(actual)
            .hasSize(expected.size())
            .containsExactlyInAnyOrderElementsOf(expected);
    }

    private static Map<String, List<String>> toProductContentIdMap(JsonNode certNode) {
        Map<String, List<String>> output = new HashMap<>();
        JsonNode products = certNode.get("products");
        assertNotNull(products);
        products.forEach(productNode -> {
            String productId = productNode.get("id").asText();

            List<String> contentIds = output.computeIfAbsent(productId, key -> new ArrayList<>());
            JsonNode content = productNode.get("content");
            assertNotNull(content);
            content.forEach(contentNode -> contentIds.add(contentNode.get("id").asText()));
        });

        return output;
    }
}
